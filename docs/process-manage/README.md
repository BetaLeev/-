# 进程管理
操作系统本身就是一种软件，本质上就是数据结构加算法。

操作系统最核心的概念是进程，操作系统的其他所有内容都是围绕进程展开的

## 进程的描述
一、程序的并发执行
1. 程序的顺序执行
早期无操作系统及单道批处理系统的计算机中，程序的执行都是典型的顺序执行。
先进入内存的程序先执行，在一个程序执行完毕之前，不能执行其他程序。程序中的指令也是依照程序的控制流依次执行，一条指令执行完毕之前不能开始执行另一条指令。
程序顺序执行时具有以下特点。

(1) 顺序性
处理机的操作，严格按照程序所规定的顺序执行，即只有前一操作结束后，才能执行后继操作。

(2) 封闭性
程序是在封闭的环境下运行的。
即程序在运行时独占全机资源，因而各资源的状态（除初始状态外）只有本程序才能改变。
程序一旦开始运行，其结果不受外界因素的影响。

(3) 可再现性
只要程序执行时的环境和初始条件相同，当程序多次重复执行时，其执行结果相同

2. 程序的并发执行
程序的并发是指在同一时间间隔内运行多个程序。一个程序执行结束之前，可以运行其他程序。
对用户而言，看到的是计算机同时运行多个程序。
程序并发执行的确切含义是从宏观上，用户看到多个程序同时向前不断地推进。
而从微观上，任意时刻一个CPU上只有一个程序在执行。
在现代单CPU或多CPU的计算机中，支持多任务及支持多用户多任务的操作系统都能够有效管理和支持程序的并发执行。
多道程序系统和分时系统都允许用户程序在计算机系统中并发执行，程序并发执行具有以下特点

(1) 间断性
程序在并发执行时，由于它们共享资源，而资源数量又往往少于并发执行的程序数量，系统不能保证每个程序不受限制地占用资源。
因而，每个程序在CPU上运行，都是时断时续的。
当请求某种资源的程序数量大于被强求的资源数量时，就必然有因申请不到资源而读暂停执行的程序。
当其他程序释放资源后，该程序才可能继续执行。
资源的有限使并发执行的程序呈现执行过程的间断性。

(2) 失去封闭性
程序在并发执行时，由于它们共享资源或者合作完成同一项任务，系统的状态不再是只有正在执行的某一个程序可以“看见”和改变。

(3) 不可再现性
程序在并发执行时，由于失去了封闭性，也将导致其失去执行结果的可在现性。
同一个程序在输入完全相同的情况下多次运行，可能出现不同的运行结果。

二、进程的概念
当操作系统支持程序并发执行时，并发执行的程序可能是同一个程序在不同数据集合上的执行，也可能是不同的程序在不同数据集合上的执行，他们共享系统资源。
用程序已不能描述程序的并发执行，所以引入了进程的概念。

1. 进程的定义

定义1：进程是允许并发执行的程序在某个数据集合上的运行过程。
定义2：进程是由正文段、用户数据段存放进进程在执行时直接进行操作的用户数据。
进程控制块存放程序的运行环境，操作系统通过这些数据描述和管理进程。
程序装入内存后就可以运行了，根据指令计数器PC的值，不断将指令从内存取到CPU的指令寄存器中，经过译码后完成各种操作。
这些指令控制的对象不外乎各种存储器（内存、外存和各种CPU寄存器）这些存储器中有待运行的指令和待处理的数据，指令只有得到CPU才能发挥其作用。

2. 进程的特征
进程是操作系统管理的实体，对应了程序的执行过程，具有以下几个特征。
(1) 并发性
多个进程尸体能在一段时间间隔内同时运行。并发性是进程和现代操作系统的重要特征。

(2) 动态性
进程是进程实体的执行过程。
进程的动态性表现在因执行程序而创建进程、因获得CPU而执行进程的指令、因运行终止而被撤销的动态变化过程。此外，进程在被创建后还有进程状态的变化。

(3) 独立性
在没有引入线程概念的操作系统中，进程是独立运行和资源调度的基本单位。

(4) 异步性
是指程序的执行时断时续，进程什么时候执行、什么时候暂停都无法预知，呈现一种随机的特性。
在终端技术出现以后，系统还需要处理随时可能出现的中断事件。

(5) 结构特征
进程实体包括用户正文段、用户数据段和进程控制块。

3. 进程与程序的比较

(1) 进程与程序的区别
程序是静态的，进程是动态的。
程序是存储在某种介质上的二进制代码，进程对应了程序执行的过程，系统不需要为一个不执行的程序创建进程，一旦进程被创建，就处于不断变化的动态过程中，对应了一个不断变化的上下文环境。
程序是与哦你更久的，进程是暂时存在的。
程序的永久性是现对于进程而言的，只要程序的拥有者不去删除它，程序可以永久地存在于磁盘、U盘等外存储介质中。
进程因程序的执行而被创建，因程序执行的结束而被撤销，有一个相对短暂的生命期。
程序与进程的存在实体不同。程序是指令的集合，而进程是包括了正文段、用户数据段和进程控制块的实体。

(2) 进程与程序的联系
进程是程序的一次执行，进程总是对应至少一个特定的程序，执行程序的代码。
一个进程可以对应多个进程。
同一个程序可以在不同的数据集合上运行，因而构成若干个不同的进程。
几个进程能并发执地行相同的程序代码，而同一个进程能顺序地执行几个程序。

三、进程控制快
操作系统的进程不仅是一个概念，而且是真实存在的实体。应用程序对应的进程由程序、用户数据和操作系统管理进程所需要的进程控制块构成。进程实体存在的标志是操作系统管理进程所使用的数据结构 - 进程控制块

1. 什么是进程控制块
进程控制块是进程实体的一部分，是操作系统中最重要的数据结构。
进程控制块中记录了操作系统所需要的、用于描述进程情况及控制进程运行所需的全部信息。
在使用C语言实现的操作系统中，这个数据结构是一个结构类型的变量。该结构类型中包含描述和管理进程需要的字段、这些字段的类型可以是简单类型，也可以是复杂类型。
操作系统在创建进程时候，首先要为进程创建进程控制块，也就是生成一个进程控制块类型的变量，以存储所创建进程的描述信息。
每个进程有唯一的进程控制块，进程控制块是操作系统感知进程存在的唯一标志。

2. 进程控制块中的信息
不同操作系统进程控制块中包含描述信息不完全相同，一般操作系统中的进程控制块中通常包含以下信息。

(1) 进程标识符信息
进程标识符用于唯一标识一个进程。进程控制块中除了存有本进程的标识符外，还存放其父进程、子进程的标识符。

(2) 处理机状态信息
处理机是被进程共享的资源，当一个进程在CPU上执行时，CPU寄存器的值随进程的执行不断变化，当发生进程切换时，当前的进程执行要被暂停，新进程占用CPU。为了使当前进程的CPU值不被新进程覆盖而丢失，必须将当前进程的CPU寄存器值保存到内存中，以便该进程再次获得CPU时，能从内存中加载寄存器的值，恢复进程上次被暂停时的CPU环境，使进程从上次被中断处继续执行。进程控制块中保留的处理机状态信息通常包括以下几个。

- 1 通用寄存器。用户程序可以访问的寄存器，用于暂存信息。
- 2 指令计数器。其中存放了CPU要访问的下一条指令的地址。
- 3 程序状态字PSW。 其中包含状态信息，如条件码、执行方式和中断屏蔽标志等。
- 4 用户栈指针。 每个用户进程都有一个与之相关的系统栈，用于存放过程和系统调用参数及调用地址，栈指针指向该栈的栈顶。

(3) 进程调度信息
进程调度信息包括进程状态信息、进程优先级和进程调度所需的其他信息。

(4) 进程控制信息
进程控制信息包括程序和数据的地址、进程同步和通信机制、资源清单，以及链接指针。

四、进程的状态
进程控制块的状态字段描述了进程当前所处的状态。它由一组标志组成，其中每个标志描述一种可能的进程状态。
Linux中进程状态字段是task_struct中的state字段。
不同操作系统在设计和实现时，定义的进程状态数量和含义有所不同，不同版本的windows，linux和unix的进程状态数都不同，对每种状态的定义也不同。
为了说明操作系统实现的原理，可以把操作系统的进程状态归结为几种基本的状态，而不影响对操作系统基本实现原理的解析。

1. 进程的3种基本状态

(1) 就绪态
就绪态是进程一旦获得CPU就可以投入运行的状态。
在多任务系统中，可以有多个处于就绪态的进程，这些进程被组织成一个或多个就绪进程队列。

(2) 执行态
执行态是进程获得CPU正在运行的状态。系统中执行态的进程数量受CPU数量的限制。单CPU系统中，任意时刻只能有一个进程处于执行态。
有N个CPU的多CPU系统中，任意时刻系统中最多有N个进程处于执行态。

(3) 阻塞态
阻塞态是进程由于等待资源或某个事件的发生而暂停执行的状态，系统不会为处于阻塞态的进程分配CPU。阻塞态进程在获得其等待的资源或其等待的事件发生之后，转变为就绪态。
处于阻塞态的进程数量可能很多，系统可以根据不同的阻塞原因将进程组织成不同的阻塞队列。

2. 进程状态的转换


3. Linux的进程状态
(1) Linux 进程状态及状态定义
- 1 可运行状态（task_running）
- 2 可中断的等待状态(task_interruptible)
- 3 不可中断的等待状态(task_uninterruptible)
- 4 暂停状态(task_stopped)
- 5 僵死状态(task_zombie)

(2) Linux2.6.11进程状态及其定义
- 1 可运行状态(task_running)
- 2 可中断的等待状态(task_interruptible)
- 3 不可中断的等待状态(task_uninterruptible)
- 4 暂停状态(task_stopeed)
- 5 跟踪状态(task_traced)
- 6 僵死状态(task_zombie)
- 7 僵死_撤销状态(exit_dead)


五、进程的组织
在操作系统中任意时刻都可能存在很多进程，每个进程对应一个进程控制块，操作系统组织和管理进程是通过管理和组织进程控制块来实现的。
管理和组织的主要目的就是要使系统中的程序在需要时能够以有效的方式检索到系统中的每一个进程。
实际上对进程的组织是通过定义数据结构来实现的。

1. 链接方式
把系统中具有相同状态的进程的进程控制块(PCB)用其中的链接字链接成一个队列

2. 索引方式
系统根据所有进程的状态，建立几张索引表，索引表的每一表项指向一个PCB的物理块。

3. 进程队列
前面讲解了进程控制块，当系统中有很多进程时，可以把进程控制块用队列组织起来，形成进程队列。
把具有相同状态的进程放在同一个队列中，具有不同状态的进程就形成了不同的进程队列。处于就绪态的进程构成的进程队列成为就绪队列，处于阻塞态的进程构成的进程队列成为阻塞队列。
根据算法的需要，又可以把就绪队列按照优先权的不同分成几个优先权不同的就绪队列，把阻塞进程根据阻塞原因的不同分成不同的阻塞队列，阻塞原因相同的进程在同一个阻塞队列中。

## 进程的控制
一、进程的创建
创建新进程包括为进程分配必要的资源，建立操作系统用于管理进程的数据结构（如进程控制块）等操作。通常在下列情况下需要创建新进程。
(1) 用户登录
在交互式系统中，当一个新用户登陆系统时会创建进程。

(2) 作业调度
当把位于外存储器中的作业调入内存准备运行时，操作系统会为作业的运行创建进程。

(3) 提供服务
操作系统可以创建一个进程，代表用户程序执行某种功能，使用户无需等待。
例如，用户请求打印一个文件，操作系统可以创建一个管理打印的进程，进而可以使请求进程继续执行，与完成打印任务的时间无关。

(4) 应用请求
当用户发出执行某程序的命令，或者用户程序在执行中基于并行的要求在程序中显式调用进程创建的系统调用时，都会引起进程的创建。

在Linux系统中，除了0号进程(swapper进程)外的其他进程都是由其父进程创建的。
在操作系统启动并正常工作后，系统中的已有进程在执行过程中都可以通过系统调用创建新进程。被创建的新进程成为创建该新进程的进程的子进程，创建者进程和被创建进程成为父子进程。一个进程可以创建多个子进程，由同一个进程创建的多个子进程之间的关系称为兄弟 进程。系统中所有的进程通过父子关系和兄弟关系被组织成一棵进程树。

通常，进程需要一定的资源（如CPU、时间、内存、文件和I/O设备）已完成其任务。
在一个进程创建子进程时，子进程可以从操作系统那里获得资源。父进程可能必须在其子进程之间分配资源或共享资源（如内存或文件）
进程被创建时，除了得到各种资源外，它还能从父进程那里得到所需要的输入数据。


二、进程的阻塞
操作系统在下列情况下可能进行进程的阻塞和唤醒操作。
(1) 请求系统服务。例如打印服务，进程在提出打印请求后，系统创建打印服务进程为该进程服务，而提出打印请求的过程可能被阻塞起来等待打印的完成。

(2) 启动某种操作。例如，进程发出启动I/O或启动打印机的命令后，等待启动完成时处于阻塞态。

(3) 新数据尚未到达。对于一个计算进程，如果新的输入数据还没有到达，计算进程要阻塞等待。

(4) 无新工作可做。发送信息之后等待时。
完成进程阻塞的简化过程如下。
- 1 将进程的状态改为阻塞态
- 2 将进程插入相应的阻塞队列
- 3 转进程调度程序，从就绪进程中 选择进程为其分配CPU
处于执行态的进程被阻塞后，CPU空闲，需要执行过程调度程序，从就绪态进程中为CPU选择一个进程运行。

三、进程的唤醒
操作系统通过下列过程将阻塞态进程唤醒，使其变成就绪态进程。进程唤醒的过程如下。
(1) 将进程从阻塞队列中移出
(2) 将进程状态由阻塞态改为就绪态
(3) 将进程插入就绪队列

四、进程的终止
进程的终止也称进程的撤销，在下列情况下，进程会被终止。
(1) 当进程正常执行完毕，调用终止进程的系统调用，请求操作系统删除该进程。
(2) 一个进程调用适当的系统调用，终止另外一个进程。通常，操作系统规定只允许父进程通过这种方式终止其子进程。

父进程终止其子进程的原因可能有以下几个
(1) 子进程使用了超过它所分配到的一些资源。
(2) 分配给子进程的任务已不再需要。
(3) 父进程退出，如果父进程终止，那么操作系统不允许子进程继续。
对于这类系统，如果一个进程终止，那么它的所有子进程也被终止。
这种现象称为级联终止，通常是由操作系统进行的。在UNIX系统中，如果父进程终止，那么其他所有子进程会以init进程作为它们新的父进程。
因此，子进程仍然有父进程可以收集它们的状态和执行统计。
操作系统通过系统调用完成进程终止的一般过程如下。
- 1 从进程PCB中读进程
- 2 若进程正在执行，则终止进程的执行
- 3 若进程有子孙进程，在大多数情况下需要终止子孙进程
- 4 释放资源
- 5 将终止进程的PCB

五、操作系统的启动和系统中进程的出现  
当打开计算机电源后，计算机会先进行加电自检，然后寻找启动盘。
如果是选择硬盘启动，计算机会检查硬盘的0柱面0磁道1扇区。
如果发现该扇区以0xAA55结束，则BIOS认为它是引导扇区，一旦发现引导扇区，BIOS会执行程序将其装入到内存地址0000:7c00处，然后跳转到该地址处执行这段引导程序代码，开始加载操作系统。
当硬盘被划分为多个分区，同时安装了多个操作系统时，每个分区都有自己的引导扇区，但是整个硬盘有一个主引导扇区，主引导扇区就是硬盘的0柱面0磁道1扇区。通过执行主引导扇区的代码，判断当前被激活的分区，然后加载被激活分区的引导扇区，通过该引导扇区代码的执行加载该激活分区的操作系统。
Linux系统从硬盘引导、加载、初始化和创建进程的简化过程

## 操作系统内核
操作系统内核是计算机硬件的第一次扩充，内核执行操作系统与硬件关系密切，执行频率高的模块，常驻内存。不同的 操作系统内核具有的功能可能是不同的。一般操作系统内核包括下列功能。

1. 支撑功能
支撑功能包括中断处理、时钟管理和原语操作。
原语操作也称原子操作，是一组在执行过程中不能被 中断的操作。

2. 资源管理功能
资源管理包括进程管理、存储器管理和设备管理。

一、中断
1. 什么是中断
中断是改变处理器执行指令顺序的一种事件，这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。
计算机在执行程序的过程中，当出现中断时，计算机停止现行程序的运行，转向对这些中断事件的处理，处理结束后再返回到现行程序的间断处。

2. 为什么需要中断
引入中断机制后，使CPU可以与其他设备并行工作，能有效提高CPU的利用率，改善系统性能，支持系统的异步性。引入中断机制前，当在CPU上执行的程序遇到I/O时，CPU采取反复轮询的方式，检测本次I/O是否结束。在轮训的过程中，CPU不能完成任何更有效的工作。引入中断机制后，一个正在执行的进程p1请求I/O后，CPU启动这次的I/O，然后在具体设备为p1的I/O服务的过程中，CPU可以先去执行其他进程。其间，CPU与进程p1的I/O是并行工作的。在本次I/O完成后，通过中断机制使CPU获得进程I/O结束的信息，转中断处理。中断处理完毕再返回到原来进程p1的断点处，继续执行后续指令，或者使p1变为就绪态进程，CPU执行其他进程。

3. 中断的类型
中断分为同步中断（也称内部中断或异常）和异步中断（也称外部中断）两种
(1) 同步中断
同步中断是指当前指令执行时由CPU控制单元产生的，之所以称为同步，是因为只有在一条指令终止执行后，CPU才会发出中断，如除法出错、调试、溢出和浮点出错等。

(2) 异步中断
异步中断是由其他硬件设备随机产生的。在Intel微处理器手册中，把同步中断和异步中断分别称为异常和中断。Linux中采用这种分类，有时也用术语“中断信号”来表示这两种类型的中断。
外部中断又可以分为外部可屏蔽中断和外部不可屏蔽中断。
- 1 外部可屏蔽中断是由I/O设备产生的中断，有两种方式可以屏蔽中断。一是如在Intel80x86的CPU上，把EFLACS寄存器的IF标志置0，表示关中断。此时，CPU忽略所有可屏蔽中断。二是可以对编程中断控制器编程来禁止中断请求。也就是说，可以告诉PIC停止对给定的IRQ线发布中断。
- 2 外部不可屏蔽中断。外部不可屏蔽中断是由紧急事件引起的中断，如硬件故障。

4. 引起中断的原因
引起中断的原因可能有以下几个

- 1 人为设置中断。在程序中人为设置中断
- 2 程序性事故。例如，计算机中出现除数为0
- 3 硬件故障。 插件接触不良、电源掉电等。
- 4 I/O设备。 I/O设备被启动以后，一旦其准备就绪或完成一次输入/输出，便向CPU发出中断请求。
- 5 外部事件。如用户通过键盘和鼠标来中断现行程序。

5. 中断响应
(1) 响应中断的条件
对于可屏蔽中断，开中断是响应中断的前提。例如，在Intel80x86CPU上，当EFLAGS寄存器的IF标志置1表示开中断。
(2) 响应中断的时机
对于外部中断，CPU每执行完一条指令都会检测是否有外部中断信号的到来。若有，则转中断处理过程。


6. 单重中断的处理过程
如图
(1) 系统关闭中断，保护断点，把当前要执行的下一条指令的地址保存到内存中，以便中断返回时，能把这个地址恢复到程序计数器PC中，使被中断的程序从断点处开始继续执行。

(2) 转中断处理程序。在中断处理程序中完成保护现场的工作，就是把相关的硬件上下文信息保存到内存中。硬件上下文就是中断返回恢复被中断程序的执行时，需要写回CPU寄存器的值。

(3) 保护完现场后，要根据中断向量到中断向量表中(Linux中是到中断描述符表中)找到与中断处理子例程入口地址相关的信息，由这些信息得到中断处理子例程的入口地址，以执行中断处理子例程，完成本次中断处理的特定处理工作。

(4) 最后，恢复现场，开中断，CPU返回断点处继续执行被中断的程序。

7. 如何找到中断服务子程序
下面以Intel80x86和Linux系统为例说明获取特定中断(键盘、鼠标和时钟中断等)服务子程序入口地址的原理。
(1) 中断向量。 中断向量是对不同中断源到来的信号编号，该编号是一个无符号整数0-255，称为中断向量。
不可屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。

(2) 中断描述符表，是一个系统表，每一个中断或异常与向量相联系。每一个向量在表中有唯一对应的表项，其中存有与中断或异常处理子例程入口地址相关的信息。内核在允许中断发生前，必须正确地初始化IDT。在操作系统初始化时，由操作系统执行汇编指令Idit加载进入内存。

二、时钟管理
1. 时钟的重要性
时钟是计算机系统的脉搏。
计算机的很多活动都是由定时测量来驱动的。计算机系统的定时测量功能对用户通常是不可见的。
操作系统的内核跟踪用户最后一次按键或移动鼠标后经过了多少事件，如果这个事件达到一个用户设定的阀值，屏幕会自动进入被保护状态。
编译系统为了缩短一个比较大的工程文件重新编译和链接的时间，对于一个工程文件中的所有源程序，并不是每次修改某一个源文件后都需要重新编译所有的源文件。通常只编译那些源文件的最后修改时间晚于相应目标文件生成时间的源程序。
操作系统的内核可以利用时钟机制防止一个进程垄断CPU或其他资源。
系统可以利用时钟机制限制一个用户进程在CPU上连续执行的时间，当进程依次连续运行的时间超过限定的时间时，由系统将CPU分配给其他进程。
计算机中当前时间显示功能、即时通信程序等与时间相关的软件都需要时钟机制的支持。

2. 计算机系统中的时钟
大部分PC中有两个时钟源，分别称为实时时钟和OS时钟。
RTC时钟也称为CMOS时钟，是一块时钟芯片，靠电池供电，为计算机提供计时标准，是最原始、最底层的数据。OS时钟产生于PC主板上的定时、计数芯片，在开机时有效，由操作系统控制。
计算机开机加电后，操作系统通过BIOS获取当前RTC时钟的值作为系统的初始时间，操作系统初始化后启用自己的时钟硬件，即可编程间隔定时器。PIT可以按照一定的频率产生时钟中断，以告知内核又一个时间间隔过去来。

3. 操作系统的时钟机制
操作系统内核需要完成两种主要的定时测量，一是保存当前的日期和时间，以便能通过系统调用把它们返回给用户程序，让用户程序获得当前的日期和时间，也可以由内核本身把当前时间作为文件和网络包的时间戳。
二是维持定时器，这种机制能够告诉内核或用户程序某一时间间隔已经过去来。
操作系统依靠时钟硬件和时钟驱动程序完成上述两种定时测量功能。
(1) OS时钟管理硬件 (可编程间隔定时器PIT)
可编程间隔定时器的功能是按指定的时间间隔产生时钟中断，测量逝去的时间，并触发与时间有关的操作。主要由3部分构成：晶振、计数器和保持寄存器。
晶振能够产生固定频率的脉冲，每产生一次脉冲，计数器的值减1，当计数器的值减为0时，产生一次时钟中断信号，保持寄存器的值再次送计数器。
由可编程间隔定时器产生的时钟中断信号送到可编程中断控制器的时钟中断信号引脚上。
(2) 时钟软件 - 时钟驱动程序
时钟驱动程序也称为时钟中断处理程序，每产生一次时钟中断信号，操作系统内核要执行时钟驱动程序，时钟驱动程序完成下列功能
- 1 维护日期和时间
- 2 递减当前进程在一个时间片内的剩余执行时间，并检查是否为零，防止进程运行超时。当前进程在一个时间片内的剩余执行时间通常记录在进程控制块中的一个字段中。该字段在进程被调度后初始化为一个时间片的长度，这个值通常用时钟中断的次数来表示。
每次处理时钟中断时，对当前进程在CPU上剩余时间值做递减操作，并检查该值递减后是否为零。若进程在CPU上的剩余时间值为零，系统执行进程调度程序，将CPU分配给其他进程；若不为零，进程可继续执行。
- 3 对CPU的使用情况记账
- 4 递减报警计数器

4. Linux时钟
(1) 时钟滴答。
OS时钟是由可编程定时/计数器输出脉冲触发中断而产生的，输出脉冲的周期称为一个时钟滴答。Linux2.4的设计者将一个至终抵达定义为10ms
(2) 时钟基准。 Linux的时间基准是1970年1月1日凌晨0点。
(3) Linux用全局变量jiffes。表示自系统启动以来的时钟滴答数。
(4) Linux提供的时间格式
(5) 与时钟中断相关的函数

三、系统调用
1. 什么是系统调用
系统调用是一群预先定义好的模块，它们提供一条管道让应用程序或一般用户能由此得到核心程序的服务。系统调用是系统程序与用户程序之间的接口，在类UNIX系统中，系统调用多使用C语言提供的库函数作为接口。

2. 系统调用与一般函数的区别
(1) 用户态执行
用户空间是指用户进程所处的地址空间，一个用户进程不能访问其他进程的用户空间，只有系统程序才能访问其他用户空间。当CPU执行用户空间的代码时，称该进程在用户态执行。

(2) 系统态执行
系统空间是指含有一切系统核心代码的地址空间，当CPU执行系统核心代码时，称进程处于系统态执行。
系统调用与一般函数调用的区别如下
- 1 系统调用运行在系统态（核心态）而一般函数运行在用户态
- 2 系统调用与一般函数调用的执行过程不同。系统调用执行时，当前进程被中断，由系统找相应的系统调用子程序，并在系统态下执行，执行结果返回进程。
- 3 系统调用要进行“中断处理”，比一般函数调用多了一些系统开销。

3. 普通函数执行过程实例
例如，调用c的库函数求一个整数的绝对值。当执行求绝对值的函数调用时，程序执行的控制流只需要转移到求绝对值的函数代码的入口处。

4. 系统调用执行过程实例


5. 系统调用的类型
根据系统调用的功能把系统调用总结为以下几种类型。
1) 进程控制类系统调用。 创建、撤销进程；获得、改变进程属性
2) 文件操纵类系统调用。 创建文件、删除文件、打开文件、关闭文件和读/写文件
3) 设备管理类系统调用。 请求、释放设备
4) 通信类系统调用。 打开、关闭连接，交换信息。
5) 信息维护类系统调用。 返回系统当前日期、时间、版本号、用户数、空闲内存和磁盘空间大小等信息。

6. Linux中的系统调用举例
- 1 fork创建一个新进程
- 2 clone按指定条件创建子进程
- 3 execve运行可执行文件
- 4 exit中止进程。 _exit立即中止当前进程
- 5 getpgid 获取指定进程组标识号
- 6 open打开文件
- 7 creat 创建新文件
- 8 close 关闭文件描述字
- 9 read 读文件
- 10 write 写文件

7. 操作系统提供系统调用的优点
- 1 使编程更加容易，把用户从学习硬件设备的低级编程特性中解放出来
- 2 极大地提高了系统的安全性

## 进程同步
一、进程同步的基本概念
二、同步机制应遵循的准则

1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

三、信号量机制

1. 整型信号量机制
2. 记录型信号量机制
3. AND型信号量机制

四、经典的进程同步问题

1. 生产者 - 消费者 问题的描述
2. 读者 - 写者问题

五、管程
1. 管程的基本概念

2. 管程的应用

## 进程通信
1. 共享存储器系统

2. 消息传递系统

3. 管道通信

4. 消息缓冲队列

## 线程
一、线程的描述
1. 线程的概念和分类
2. 线程的3种基本状态
3. 线程控制快
4. 线程与进程的关系

二、线程的控制
1. 线程创建
2. 线程的终止
3. 线程的调度与切换
4. 线程的阻塞与唤醒

三、线程的同步

四、线程通信