# 内存管理
当操作系统接收道运行某程序道命令后，要为该程序的运行分配内存资源，创建进程，并把进程的全部或部分调入内存。

进程运行结束，系统要回收被撤销进程的内存空间。

内存管理的目标一方面是实现内存分配、内存回收等基本内存管理功能，另一方面是要提高内存空间的利用率和内存的访问速度。

每个程序员都希望自己都程序能运行在一个独占的、容量充分大、访问速度足够快的存储器上。然而，事实上计算机的内存是有限的，而且是被许多应用程序共享的。

处于同一内存中的不同进程之间必然会存在竞争与相互影响。操作系统的内存管理正是解决这一问题的，其目标是充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器。


##  存储器的层次结构
内存是计算机存储系统的一部分。
存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。

CPU寄存器保存最常用的数据。靠近CPU的容量小、速度快的高速缓存存储器作为速度相对较慢、容量较大的主存中数据和指令子集的缓冲区。主存暂时存放容量更大、速度更慢的磁盘上的数据。而这些磁盘常常又作为存储在通过网络链接的其他及其的磁盘或磁带上的数据的缓冲区。

如果程序需要的数据是存放在CPU寄存器中的，程序执行期间在零个周期内就可以访问道它们。如果存储在高速缓存中，需要1-10个周期，如果这些数据存放在主存中，访问它们需要50-100个周期。而如果这些数据是存放在磁盘中的，要访问它们需要大约2000万个周期。

程序的执行遵循局部性原理。程序执行的局部性原理指出，程序在执行时呈现出局部性规律，即在一段较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。

关于程序执行的局部性原理有以下几个论点。

1. 程序在执行时，除了少部分的转移和过程调用指令以外，在大多数情况下是顺序执行的。

2. 过程调用将会使程序的执行轨迹由一部分内存区域转移道另一部分内存区域。但研究表明，在大多数情况下，过程调用的深度都不超过5.

3. 程序中存在很多循环结构，它们虽然由少数指令构成，但多次执行。

4. 程序中往往包括许多对数据结构对处理。例如对数组进行操作，它们往往都局限在很小都范围内。

总的来说，局部性原理表现为时间和空间都局限性。

1. 时间局限性。如果程序中都某条指令一旦执行，则不久后该指令可能再次执行。如果某个数据结构被访问，不久以后该数据结构可能被再次访问。

2. 空间局限性。一旦程序访问了某个但愿，在不久以后，其附近的存储但愿也将被访问。

具有良好局部性的程序会经常访问相同的数据集合或相邻的数据集合。

具有良好局部性的程序比局部性差的程序能更好地利用处于高层次的存储器，因此运行速度更快。


## 程序的链接和接入
高级语言程序必须经过编译、链接才能成为可执行程序，操作系统需要为程序的执行分配内存空间。

下面介绍链接程序的功能和程序被装入内存的几种方式。

一、程序的链接
链接程序不属于操作系统的构成部分，但是它为操作系统提供可装入的程序模块。

链接 程序要解决的问题是将编译后的目标模块装配成一个可执行的程序。根据程序进行的时间和实现方式的不同，可以把链接分为静态链接和动态链接。

1. 静态链接
静态链接（static linking）是在程序运行前，用链接程序将目标模块链接成一个完整的装入模卡。静态链接程序的任务一是对逻辑地址进行修改，二是变换外部调用符号。

1) 对逻辑地址进行修改

2) 变换外部调用符号

静态链接相对于动态链接而言，程序运行速度较快。但是无论程序在本次运行中会不会被执行，都将全部被链接到一个可执行文件中，使可执行文件比较大，占用的内、外存空间较大，使存储开销较大。
另外，使用静态链接的方式，程序开发不够灵活、方便，修改某一个模块会导致整个程序的重新链接。


2. 动态链接
采用动态链接（Run-time Dynamic Linking）,可将某些目标模块的链接推迟到这些模块中的函数被调用执行时才进行。即在程序执行时，若发现一个被调用模块尚未链接，再把它链接到调用者模块上。采用动态链接的优点是节省内存和外存空间，方便了程序开发。
例如开发一个图形控件，若让图形控件以动态链接库的形式存在，整个控件就可以独立开发，独立编译和链接。但由于动态链接是在程序运行过程中从外存将被调用的模块调入内存并链接到调用者模块上，这需要运行时的时间开销，会使程序运行时的速度变慢。

二、 程序的装入

在多道程序环境下，程序要运行必须为之创建进程，而创建进程后，不可避免地要为进程分配内存，并将进程的程序和数据装入内存。将一个用户的源程序变为一个可在内存中执行的程序，通常要经过编译、链接和装入3个阶段。

通常，可执行程序以二进制可执行文件的形式存储在磁盘上，为执行程序，操作系统需要把程序调入内存。

多数系统允许操作系统将用户进程放在物理内存的任意位置。因此，虽然计算机的地址空间从0开始，但用户进程的起始地址不一定是0。在绝大多数情况下，源程序需要经过编译、链接和装入几个阶段才能执行。在不同阶段，程序地址有不同的表示形式。源程序中的地址通常是符号表示，如一个模型变量counter。编译器将这些符号地址变为可重定位地址，通常是相对于本模块开始位置的地址。例如，被编译模块的起始地址为0，所有符号地址都转变成相对于0开始的一个逻辑地址。每一次的地址变化都是从一个地址空间到另一个地址空间的映射。根据形成在内存中物理地址的时机不同，把程序的装入方式分为绝对装入方式、可重定位装入方式（静态重定位）和动态运行时装入方式。

1. 绝对装入方式

2. 可重定位装入方式（静态重定位）

3. 动态运行时装入（动态重定位）

## 连续分配存储管理方式
连续分配是指操作系统分配内存时，为每个进程分配一块物理地址连续的内存空间。连续分配方式有3种类型。

1. 单一连续区分配方式
内存中只有一个用户区，任意时刻内存种只能装入一道程序，这种分配方式仅适用于单用户、单任务的系统。

2. 固定分区分配方式
将内存用户区划分成若干个固定大小的区域，每个区域中驻留一道程序。

3. 动态分区分配方式
系统动态地对内存进行划分，根据进程需要的空间大小分配内存。内存中分区的大小和数量是变化的。动态分区方式比固定分区方式显著地提高了内存利用率。


一、单一连续分配
单一连续分配方式适用于单用户、单任务的操作系统，它把内存分为系统区和用户区。
系统区仅供操作系统使用，用户区供用户使用。
系统区用于驻留操作系统，用户区用于分配给用户进程使用，为了防止用户程序对操作系统的破坏，保证系统的安全、可靠，在操作系统中应该考虑设置存储器保护机制。在单用户、单任务操作系统中较常用的方法是设置一个基址寄存器和一个界限寄存器。基址寄存器中存放装入用户区程序的地址范围。在CPU访问内存时，检查CPU要访问的内存但愿的地址是否大于界限寄存器的值。如果大于界限寄存器中的地址范围，则是非法地址，表示用户进程访问存越界，程序执行会被中断。
在有些单用户、单任务的操作系统，如CM/M和MS-DOS中，没有设置存储器保护机制。
其理由为：一是节省硬件；二是单任务单用户系统中，用户独占机器，对系统的破坏只可能是自己造成的，后果也不严重，不会影响其他用户程序的执行，而且操作系统很容易重装和再次启动。

二、固定分区分配
固定分区分配将用户内存空间划分为若干个固定大小的区域，在每个用户区中可以装入一道用户程序。
内存的用户区被划分为几个分区，便允许几个进程并发运行。当有一个空闲分区时，可从外存的后备队列中选择一个大小适当的作业装入该分区。当该作业结束h时，释放所占用的分区，系统又可从后备作业队列中找出另一个作业调入该分区。

1. 划分分区的方法
固定分区分配的用户分区数量是固定的，每个分区的大小也是固定的。但是每个分区的大小可以相等，也可以不相等。
1) 分区大小相等
在这种设计中，把用户区划分成大小相等的若干个分区。这种设计的缺点是内存利用率比较低。当程序太小时，该程序所占用的分区有很大一部分是空闲的。而程序较大时，可能找不到一个分区足以装下该程序。这种设计主要用于利用一台计算机去控制多个相同对象的场合，因为这种情况下，各用户进程需要的空间大小相同，例如用一台计算机控制多台相同的冶炼炉。

2)分区大小不等
为了更好地利用内存，可以将用户区划分成大小不同、数量固定的若干个分区。为用户进程分配空间时，把大小最接近进程大小的空闲区分配给申请内存空间的进程。使小进程占小分区，大进程占大分区，减少内存浪费。

2. 支持固定分区分配的数据结构
操作系统为了完成对固定分区的管理，必须定义一个记录用户分区大小和使用情况的数据结构
写程序时数据结构的定义根据具体系统的需要和算法的需要来调整

3. 固定分区分配的过程
需要为进程分配内存时，操作系统执行内存分配程序，搜索内存分区使用表。当找到一个大小或等于进程需要的内存空间而且处于空闲状态的用户分区时，将该分区分配给进程，并将该分区状态改为“已占用”。在上面的数据结构中，就是将相应分区的state字段置为1.

4. 固定分区的回收
当进程运行结束后，系统要回收进程占用的分区。通过执行内存回收程序完成回收操作，只要把回收分区的使用状态改为“空闲”即可，即把上面数据结构中相应分区的state字段置0。
固定分区分配实现简单，但是由于每个分区的大小固定，必然造成存储空间的浪费，使内存利用率低下。现在的多道程序系统很少使用固定分区分配的内存管理模式。但是，在一些实时控制系统中，使用固定分区分配还是简单而有效的。

三、动态分区分配
由于固定分区分配将内存空间划分成大小固定的分区，当运行需要的内存空间比分区大的进程时，固定分区无法满足要求。而当运行只需要很小空间的进程时，内存空间浪费大。使用固定分区分配内存利用率低，难以提高系统的多道程序度。动态分区分配是根据进程的实际需要，为进程分配大小合适的内存区域。系统中用户分区的数量和大小都是动态变化的。
主要有3部分
1) 动态分区分配使用的数据结构
2) 动态分区分配算法
3) 动态分区的分配和回收操作

1. 动态分区分配原理
动态分区分配算法的原理：系统初始只有一个大空闲去，当进程请求空间时，由系统根据进程需要的空间大小划分出一片空闲区分配给进程。系统运行一段时间后，内存的空闲区可能散步在不连续的区域。系统维护一个记录当前空闲分区情况的数据结构，当进程请求内存时，系统从所有空闲区中找到大小合适的空闲分区进行分配。系统中分区的大小和数量都是变化的，空闲区的大小和数量也是变化的。

2. 动态分区分配中的数据结构
为实现动态区分配，系统需要建立并维护记录空闲分区情况的数据结构。常用的数据结构有空闲分区表和空闲分区链。
1) 空闲分区表
2) 空闲分区链
使用空闲分区链可以动态地为每一个空闲分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区结点的指针，以及指向后一个空闲分区结点的指针。空闲分区链中的每个结点占用的内存可以动态分配、动态回收。使用空闲分区链可以克服空闲分区表存在的缺点。

3. 动态分区分配算法
当进程需要内存空间时，操作系统通过执行动态分区分配算法从多个空闲分区中选定一个合适的分区分配给进程。不同的分区分配算法有不同的特点，需要不同数据结构的支持。
有3种动态分区分配算法，即首次适应算法、循环首次适应算法和最佳适应算法。
1) 首次适应算法

2) 循环首次适应算法

3) 最佳适应算法

4. 动态分区分配的流程
采取动态分区分配的内存管理方式，内存分配功能由内存分配程序完成，内存分配程序采用某种内存分配算法为进程分配内存。内存不再被应用程序需要时，由系统调用内存回收程序回收原来占用的内存分区。

## 基本分页存储管理方式

把进程离散地存储在内存中物理地址不连续的区域中，这种内存管理方式成为离散内存管理方式。
为了支持虚拟内存管理，需要引入离散内存管理方式。根据离散内存管理分配内存空间的基本单位的不同，将其分为3种不同的管理方式：分页存储管理、分段存储管理和段页式存储管理

一、分页存储管理的基本原理

1. 基本概念
(1) 页 Page
将一个进程的逻辑地址空间分成若干个大小相等的片，成为页。

(2) 页框 Page Frame
将物理内存空间分成与页大小相同的若干个存储块，称为页框或页帧。

(3) 分页存储
在为进程分配内存时，以页框为单位将内存中的若干页分别装入多个可以不相邻接的页框中。

(4) 页内碎片
进程的最后一页一般装不满一个页框，而形成了不可利用的碎片，称为“页内碎片”是一种内部碎片。

(5) 页表(Page Table)
页表是系统为进程建立的数据结构，页表的作用是实现从页号到页框号的映射。

2. 基本分页存储管理方式中的地址结构
基本分页的逻辑地址结构包含两部分：页号P和页内偏移量W。

3. 分页地址更换
为了能将用户地址空间中的逻辑地址变换为内存空间中的物理地址，在系统中必须设置地址变换机构，该机构的基本任务是实现逻辑地址到物理地址的变换。

4. 页大小的选择
在分页系统中，页的大小是由机器的体系结构和操作系统共同决定的。对于某一种机器只能支持几种固定的页大小，一旦操作系统选定了一种页大小，系统中所有进程的页大小就固定不变了。
在设计系统时，如何选择页大小呢？选择较小的页，可以减少页内碎片及所有进程页内碎片的综合。
但较小的页会使进程的页数较多，页表较长，页表所需占用的连续内存空间比较大。而且较小、较多的页会导致进程的缺页率高，页换入、换出频率。若选择较大的页，页的大小为2的整数次幂。在目前的计算机系统中，大多选择4KB大小的页。
归纳影响页大小设计的因素如下。
(1) 管理内存的开销
选择较小的页，会导致进程被划分为较多的页，页表过长，占用大量内存空间。同时，进程的缺页率和置换率都会比较高，内存管理的时间开销相对大。

(2)内存的利用率
选择较小的页，有利于提高内存的利用率，但存在（1）所述的缺点。选择较大的页，可克服（1）所述的缺点，但页内碎片大，空间利用率降低。

二、快表
页表的硬件实现有多种方法，最为简单的一种方法就是将页表存放在一组专用寄存器中，进程调度程序选中新的进程执行时，更新这组寄存器的置，把当前进程的页表装入寄存器。操作系统使用特权级指令装入或修改页表寄存器的值。

1. 什么是快表
快表也称转换后援缓冲，是为了提高CPU访存速度而采用的专用缓存，用来存放最近被访问过的页表项。TLB是关联的快速闪存。TLB的条目由两部分组成：键和值。 键部分对应页号，值部分对应页所在的页框号。当关联内存查找TLB中的页表项时，会同时与所有键进行比较，如果找到条目，就得到相应的值域，从而得到页的页框号。这种查找方式比较快，但是硬件比较昂贵。通常TLB的条目数很有限，在64到1024个之间

2. 引入TLB之后的地址变换过程
地址变换过程可以概括为一下3个步骤。
1) CPU产生分页的逻辑地址页号
2) 查找TLB，如果找到页号，则把该页所在的页框号用于形成物理地址。
3) 如果所查找的页表项不在TLB中，在访问完内存页表后，要把找到的页表项中的页号和页框号写到TLB中。如果TLB中的条目已满，系统会根据某种策略（如最近最少使用替换）选择一个TLB中的条目，用刚访问的页表项信息替换选中的这个TLB条目。

3. 引入TLB的性能分析
在TLB中找到某一个页号对应的页表项中的百分比称为TLB命中率。当能在TLB中找到所需要的表项时，有效访存时间等于一次访问TLB的时间加上一次访问内存的时间。当没有在TLB中找到所需要的页表项时，访存时间等于一次访问TLB的时间加上两次访问内存的时间。

三、两级和多级页表
现代计算机都支持很大的逻辑地址空间，如32位系统的4GB，64位系统的2^24TB。使用前面所讲的基本分页存储，回忆以下3个知识点。
1)每个进程有一个页表。
2)每个页表至少包含与进程页数相同的页表项数。
3)页表必须连续存放。

1. 两级页表
两级页表是将页表再进行分页，使每个页表分页的大小与内存页框的大小相同，并为它们编号。将这些页表分页分别放入不同的、不一定相邻的页框中，为离散分配的页表再建立一张外层页表。

2. 多级页表结构
对于64位的机器，使用二级页表，仍存在连续占用大量内存的问题，可以采用多级页表结构，将外存页表再分若干页，然后为外存页表建立连续存放的索引表。

四、反置页表

1. 反置页表
现代系统中可能存在大量进程，每个进程都允许很大的逻辑地址空间，因而进程可能拥有一个很大的页表，这些页表会占用大量的物理内存空间。为了解决这个问题，可以使用反置页表，为每一个页框设一个表项，表项中存放进程号和页号，系统只维护一张反置页表即可。由于物理存储空间小于逻辑存储空间，所以使用反置页表减少了页表占用的内存空间。

2. 反置页表的地址映射
在利用反置页表进行地址变换时，是用进程标志符（进程号）和页号去检索反置页表以获取页框号。地址映射过程如下。
1) 根据进程号和页号找到页框号
2) 物理地址 = 页框号 x 页框大小 + 页内偏移地址。

五、 空闲页框的管理
操作系统需要跟踪和记录空闲页框的信息，两种管理空闲页框的方式。

1. 使用位图管理空闲页框
使用位图管理空闲页框时，使位图中的每一位对应一个页框，具有N个页框的内存需要至少有N个二进制位的位图。当某个二进制位对应的页框被占用时，将该位置1。当该页框空闲时，该位置0.当操作系统为进程分配页框时，检索位图，找对应位为0的页框分配给进程。

2. 使用空闲页框的链表
使用空闲页框链表时，系统维护记录空闲页框信息的链表。空闲页框链表可以按地址递增的顺序排序，每个结点中包含页框的地址信息、指向后面结点的指针和指向前面结点的指针。

## 基于分页的虚拟存储系统

一、请求分页中的硬件支持

1. 页表

2. 缺页异常机构

3. 地址变换

二、页分配策略

1. 最少页框数

2. 页分配和置换策略

3. 分配算法

三、页调入策略

1. 何时调入页

2. 从何处调入页

3. 页调入过程

四、页置换算法

1. 最佳置换算法和先进先出置换算法

2. 最近最久未使用LRU置换算法

3. 其他置换算法

五、请求分页系统的性能分析

1. 缺页率对有效访问时间对影响

2. 工作集

3. 抖动产生对原因和预防方法

## 分段存储管理

## Linux的伙伴系统
因为在操作系统中，经常会遇到要为进程分配连续物理内存块的情况，典型的如在Linux中创建新进程时，需要为进程分配连续的8kb空间，即两个连续的页框用于存放task_struc结构和进程的内核推栈。因此，内核应该为分配一组连续的页框而建立一种稳定、高效的分配策略。

Linux的伙伴系统算法把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续的页框。对1024个页框的最大请求对应着4MB大小的连续页框。每个块的第一个页框的物理地址是该块大小的整数倍。例如大小为16个页框的块，其起始地址为16*12的倍数。

