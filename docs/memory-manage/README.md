# 内存管理
当操作系统接收道运行某程序道命令后，要为该程序的运行分配内存资源，创建进程，并把进程的全部或部分调入内存。

进程运行结束，系统要回收被撤销进程的内存空间。

内存管理的目标一方面是实现内存分配、内存回收等基本内存管理功能，另一方面是要提高内存空间的利用率和内存的访问速度。

每个程序员都希望自己都程序能运行在一个独占的、容量充分大、访问速度足够快的存储器上。然而，事实上计算机的内存是有限的，而且是被许多应用程序共享的。

处于同一内存中的不同进程之间必然会存在竞争与相互影响。操作系统的内存管理正是解决这一问题的，其目标是充分利用现有的内存资源，为应用程序提供方便的内存使用方式和一个快速、安全且充分大的存储器。


##  存储器的层次结构
内存是计算机存储系统的一部分。
存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。

CPU寄存器保存最常用的数据。靠近CPU的容量小、速度快的高速缓存存储器作为速度相对较慢、容量较大的主存中数据和指令子集的缓冲区。主存暂时存放容量更大、速度更慢的磁盘上的数据。而这些磁盘常常又作为存储在通过网络链接的其他及其的磁盘或磁带上的数据的缓冲区。

如果程序需要的数据是存放在CPU寄存器中的，程序执行期间在零个周期内就可以访问道它们。如果存储在高速缓存中，需要1-10个周期，如果这些数据存放在主存中，访问它们需要50-100个周期。而如果这些数据是存放在磁盘中的，要访问它们需要大约2000万个周期。

程序的执行遵循局部性原理。程序执行的局部性原理指出，程序在执行时呈现出局部性规律，即在一段较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。

关于程序执行的局部性原理有以下几个论点。

1. 程序在执行时，除了少部分的转移和过程调用指令以外，在大多数情况下是顺序执行的。

2. 过程调用将会使程序的执行轨迹由一部分内存区域转移道另一部分内存区域。但研究表明，在大多数情况下，过程调用的深度都不超过5.

3. 程序中存在很多循环结构，它们虽然由少数指令构成，但多次执行。

4. 程序中往往包括许多对数据结构对处理。例如对数组进行操作，它们往往都局限在很小都范围内。

总的来说，局部性原理表现为时间和空间都局限性。

1. 时间局限性。如果程序中都某条指令一旦执行，则不久后该指令可能再次执行。如果某个数据结构被访问，不久以后该数据结构可能被再次访问。

2. 空间局限性。一旦程序访问了某个但愿，在不久以后，其附近的存储但愿也将被访问。

具有良好局部性的程序会经常访问相同的数据集合或相邻的数据集合。

具有良好局部性的程序比局部性差的程序能更好地利用处于高层次的存储器，因此运行速度更快。


## 程序的链接和接入
高级语言程序必须经过编译、链接才能成为可执行程序，操作系统需要为程序的执行分配内存空间。

下面介绍链接程序的功能和程序被装入内存的几种方式。

一、程序的链接
链接程序不属于操作系统的构成部分，但是它为操作系统提供可装入的程序模块。

链接 程序要解决的问题是将编译后的目标模块装配成一个可执行的程序。根据程序进行的时间和实现方式的不同，可以把链接分为静态链接和动态链接。

1. 静态链接
静态链接（static linking）是在程序运行前，用链接程序将目标模块链接成一个完整的装入模卡。静态链接程序的任务一是对逻辑地址进行修改，二是变换外部调用符号。

1) 对逻辑地址进行修改

2) 变换外部调用符号

静态链接相对于动态链接而言，程序运行速度较快。但是无论程序在本次运行中会不会被执行，都将全部被链接到一个可执行文件中，使可执行文件比较大，占用的内、外存空间较大，使存储开销较大。
另外，使用静态链接的方式，程序开发不够灵活、方便，修改某一个模块会导致整个程序的重新链接。


2. 动态链接
采用动态链接（Run-time Dynamic Linking）,可将某些目标模块的链接推迟到这些模块中的函数被调用执行时才进行。即在程序执行时，若发现一个被调用模块尚未链接，再把它链接到调用者模块上。采用动态链接的优点是节省内存和外存空间，方便了程序开发。
例如开发一个图形控件，若让图形控件以动态链接库的形式存在，整个控件就可以独立开发，独立编译和链接。但由于动态链接是在程序运行过程中从外存将被调用的模块调入内存并链接到调用者模块上，这需要运行时的时间开销，会使程序运行时的速度变慢。

二、 程序的装入

在多道程序环境下，程序要运行必须为之创建进程，而创建进程后，不可避免地要为进程分配内存，并将进程的程序和数据装入内存。将一个用户的源程序变为一个可在内存中执行的程序，通常要经过编译、链接和装入3个阶段。

通常，可执行程序以二进制可执行文件的形式存储在磁盘上，为执行程序，操作系统需要把程序调入内存。

多数系统允许操作系统将用户进程放在物理内存的任意位置。因此，虽然计算机的地址空间从0开始，但用户进程的起始地址不一定是0。在绝大多数情况下，源程序需要经过编译、链接和装入几个阶段才能执行。在不同阶段，程序地址有不同的表示形式。源程序中的地址通常是符号表示，如一个模型变量counter。编译器将这些符号地址变为可重定位地址，通常是相对于本模块开始位置的地址。例如，被编译模块的起始地址为0，所有符号地址都转变成相对于0开始的一个逻辑地址。每一次的地址变化都是从一个地址空间到另一个地址空间的映射。根据形成在内存中物理地址的时机不同，把程序的装入方式分为绝对装入方式、可重定位装入方式（静态重定位）和动态运行时装入方式。

1. 绝对装入方式

2. 可重定位装入方式（静态重定位）

3. 动态运行时装入（动态重定位）

## 连续分配存储管理方式
连续分配是指操作系统分配内存时，为每个进程分配一块物理地址连续的内存空间。连续分配方式有3种类型。

1. 单一连续区分配方式
内存中只有一个用户区，任意时刻内存种只能装入一道程序，这种分配方式仅适用于单用户、单任务的系统。

2. 固定分区分配方式
将内存用户区划分成若干个固定大小的区域，每个区域中驻留一道程序。

3. 动态分区分配方式
系统动态地对内存进行划分，根据进程需要的空间大小分配内存。内存中分区的大小和数量是变化的。动态分区方式比固定分区方式显著地提高了内存利用率。


一、单一连续分配
单一连续分配方式适用于单用户、单任务的操作系统，它把内存分为系统区和用户区。
系统区仅供操作系统使用，用户区供用户使用。
系统区用于驻留操作系统，用户区用于分配给用户进程使用，为了防止用户程序对操作系统的破坏，保证系统的安全、可靠，在操作系统中应该考虑设置存储器保护机制。在单用户、单任务操作系统中较常用的方法是设置一个基址寄存器和一个界限寄存器。基址寄存器中存放装入用户区程序的地址范围。在CPU访问内存时，检查CPU要访问的内存但愿的地址是否大于界限寄存器的值。如果大于界限寄存器中的地址范围，则是非法地址，表示用户进程访问存越界，程序执行会被中断。
在有些单用户、单任务的操作系统，如CM/M和MS-DOS中，没有设置存储器保护机制。
其理由为：一是节省硬件；二是单任务单用户系统中，用户独占机器，对系统的破坏只可能是自己造成的，后果也不严重，不会影响其他用户程序的执行，而且操作系统很容易重装和再次启动。

二、固定分区分配
固定分区分配将用户内存空间划分为若干个固定大小的区域，在每个用户区中可以装入一道用户程序。
内存的用户区被划分为几个分区，便允许几个进程并发运行。当有一个空闲分区时，可从外存的后备队列中选择一个大小适当的作业装入该分区。当该作业结束h时，释放所占用的分区，系统又可从后备作业队列中找出另一个作业调入该分区。

1. 划分分区的方法
固定分区分配的用户分区数量是固定的，每个分区的大小也是固定的。但是每个分区的大小可以相等，也可以不相等。
1) 分区大小相等
在这种设计中，把用户区划分成大小相等的若干个分区。这种设计的缺点是内存利用率比较低。当程序太小时，该程序所占用的分区有很大一部分是空闲的。而程序较大时，可能找不到一个分区足以装下该程序。这种设计主要用于利用一台计算机去控制多个相同对象的场合，因为这种情况下，各用户进程需要的空间大小相同，例如用一台计算机控制多台相同的冶炼炉。

2)分区大小不等
为了更好地利用内存，可以将用户区划分成大小不同、数量固定的若干个分区。为用户进程分配空间时，把大小最接近进程大小的空闲区分配给申请内存空间的进程。使小进程占小分区，大进程占大分区，减少内存浪费。

2. 支持固定分区分配的数据结构
操作系统为了完成对固定分区的管理，必须定义一个记录用户分区大小和使用情况的数据结构
写程序时数据结构的定义根据具体系统的需要和算法的需要来调整

3. 固定分区分配的过程
需要为进程分配内存时，操作系统执行内存分配程序，搜索内存分区使用表。当找到一个大小或等于进程需要的内存空间而且处于空闲状态的用户分区时，将该分区分配给进程，并将该分区状态改为“已占用”。在上面的数据结构中，就是将相应分区的state字段置为1.

4. 固定分区的回收
当进程运行结束后，系统要回收进程占用的分区。通过执行内存回收程序完成回收操作，只要把回收分区的使用状态改为“空闲”即可，即把上面数据结构中相应分区的state字段置0。
固定分区分配实现简单，但是由于每个分区的大小固定，必然造成存储空间的浪费，使内存利用率低下。现在的多道程序系统很少使用固定分区分配的内存管理模式。但是，在一些实时控制系统中，使用固定分区分配还是简单而有效的。

三、动态分区分配
由于固定分区分配将内存空间划分成大小固定的分区，当运行需要的内存空间比分区大的进程时，固定分区无法满足要求。而当运行只需要很小空间的进程时，内存空间浪费大。使用固定分区分配内存利用率低，难以提高系统的多道程序度。动态分区分配是根据进程的实际需要，为进程分配大小合适的内存区域。系统中用户分区的数量和大小都是动态变化的。
主要有3部分
1) 动态分区分配使用的数据结构
2) 动态分区分配算法
3) 动态分区的分配和回收操作

1. 动态分区分配原理
动态分区分配算法的原理：系统初始只有一个大空闲去，当进程请求空间时，由系统根据进程需要的空间大小划分出一片空闲区分配给进程。系统运行一段时间后，内存的空闲区可能散步在不连续的区域。系统维护一个记录当前空闲分区情况的数据结构，当进程请求内存时，系统从所有空闲区中找到大小合适的空闲分区进行分配。系统中分区的大小和数量都是变化的，空闲区的大小和数量也是变化的。

2. 动态分区分配中的数据结构
为实现动态区分配，系统需要建立并维护记录空闲分区情况的数据结构。常用的数据结构有空闲分区表和空闲分区链。
1) 空闲分区表
2) 空闲分区链
使用空闲分区链可以动态地为每一个空闲分区建立一个节点，每个节点包括分区大小、分区起始地址、指向前一个空闲分区结点的指针，以及指向后一个空闲分区结点的指针。空闲分区链中的每个结点占用的内存可以动态分配、动态回收。使用空闲分区链可以克服空闲分区表存在的缺点。

3. 动态分区分配算法
当进程需要内存空间时，操作系统通过执行动态分区分配算法从多个空闲分区中选定一个合适的分区分配给进程。不同的分区分配算法有不同的特点，需要不同数据结构的支持。
有3种动态分区分配算法，即首次适应算法、循环首次适应算法和最佳适应算法。
1) 首次适应算法

2) 循环首次适应算法

3) 最佳适应算法

4. 动态分区分配的流程
采取动态分区分配的内存管理方式，内存分配功能由内存分配程序完成，内存分配程序采用某种内存分配算法为进程分配内存。内存不再被应用程序需要时，由系统调用内存回收程序回收原来占用的内存分区。

## 基本分页存储管理方式

把进程离散地存储在内存中物理地址不连续的区域中，这种内存管理方式成为离散内存管理方式。
为了支持虚拟内存管理，需要引入离散内存管理方式。根据离散内存管理分配内存空间的基本单位的不同，将其分为3种不同的管理方式：分页存储管理、分段存储管理和段页式存储管理

一、分页存储管理的基本原理

1. 基本概念
(1) 页 Page
将一个进程的逻辑地址空间分成若干个大小相等的片，成为页。

(2) 页框 Page Frame
将物理内存空间分成与页大小相同的若干个存储块，称为页框或页帧。

(3) 分页存储
在为进程分配内存时，以页框为单位将内存中的若干页分别装入多个可以不相邻接的页框中。

(4) 页内碎片
进程的最后一页一般装不满一个页框，而形成了不可利用的碎片，称为“页内碎片”是一种内部碎片。

(5) 页表(Page Table)
页表是系统为进程建立的数据结构，页表的作用是实现从页号到页框号的映射。

2. 基本分页存储管理方式中的地址结构
基本分页的逻辑地址结构包含两部分：页号P和页内偏移量W。

3. 分页地址更换
为了能将用户地址空间中的逻辑地址变换为内存空间中的物理地址，在系统中必须设置地址变换机构，该机构的基本任务是实现逻辑地址到物理地址的变换。

4. 页大小的选择
在分页系统中，页的大小是由机器的体系结构和操作系统共同决定的。对于某一种机器只能支持几种固定的页大小，一旦操作系统选定了一种页大小，系统中所有进程的页大小就固定不变了。
在设计系统时，如何选择页大小呢？选择较小的页，可以减少页内碎片及所有进程页内碎片的综合。
但较小的页会使进程的页数较多，页表较长，页表所需占用的连续内存空间比较大。而且较小、较多的页会导致进程的缺页率高，页换入、换出频率。若选择较大的页，页的大小为2的整数次幂。在目前的计算机系统中，大多选择4KB大小的页。
归纳影响页大小设计的因素如下。
(1) 管理内存的开销
选择较小的页，会导致进程被划分为较多的页，页表过长，占用大量内存空间。同时，进程的缺页率和置换率都会比较高，内存管理的时间开销相对大。

(2)内存的利用率
选择较小的页，有利于提高内存的利用率，但存在（1）所述的缺点。选择较大的页，可克服（1）所述的缺点，但页内碎片大，空间利用率降低。

二、快表
页表的硬件实现有多种方法，最为简单的一种方法就是将页表存放在一组专用寄存器中，进程调度程序选中新的进程执行时，更新这组寄存器的置，把当前进程的页表装入寄存器。操作系统使用特权级指令装入或修改页表寄存器的值。

1. 什么是快表
快表也称转换后援缓冲，是为了提高CPU访存速度而采用的专用缓存，用来存放最近被访问过的页表项。TLB是关联的快速闪存。TLB的条目由两部分组成：键和值。 键部分对应页号，值部分对应页所在的页框号。当关联内存查找TLB中的页表项时，会同时与所有键进行比较，如果找到条目，就得到相应的值域，从而得到页的页框号。这种查找方式比较快，但是硬件比较昂贵。通常TLB的条目数很有限，在64到1024个之间

2. 引入TLB之后的地址变换过程
地址变换过程可以概括为一下3个步骤。
1) CPU产生分页的逻辑地址页号
2) 查找TLB，如果找到页号，则把该页所在的页框号用于形成物理地址。
3) 如果所查找的页表项不在TLB中，在访问完内存页表后，要把找到的页表项中的页号和页框号写到TLB中。如果TLB中的条目已满，系统会根据某种策略（如最近最少使用替换）选择一个TLB中的条目，用刚访问的页表项信息替换选中的这个TLB条目。

3. 引入TLB的性能分析
在TLB中找到某一个页号对应的页表项中的百分比称为TLB命中率。当能在TLB中找到所需要的表项时，有效访存时间等于一次访问TLB的时间加上一次访问内存的时间。当没有在TLB中找到所需要的页表项时，访存时间等于一次访问TLB的时间加上两次访问内存的时间。

三、两级和多级页表
现代计算机都支持很大的逻辑地址空间，如32位系统的4GB，64位系统的2^24TB。使用前面所讲的基本分页存储，回忆以下3个知识点。
1)每个进程有一个页表。
2)每个页表至少包含与进程页数相同的页表项数。
3)页表必须连续存放。

1. 两级页表
两级页表是将页表再进行分页，使每个页表分页的大小与内存页框的大小相同，并为它们编号。将这些页表分页分别放入不同的、不一定相邻的页框中，为离散分配的页表再建立一张外层页表。

2. 多级页表结构
对于64位的机器，使用二级页表，仍存在连续占用大量内存的问题，可以采用多级页表结构，将外存页表再分若干页，然后为外存页表建立连续存放的索引表。

四、反置页表

1. 反置页表
现代系统中可能存在大量进程，每个进程都允许很大的逻辑地址空间，因而进程可能拥有一个很大的页表，这些页表会占用大量的物理内存空间。为了解决这个问题，可以使用反置页表，为每一个页框设一个表项，表项中存放进程号和页号，系统只维护一张反置页表即可。由于物理存储空间小于逻辑存储空间，所以使用反置页表减少了页表占用的内存空间。

2. 反置页表的地址映射
在利用反置页表进行地址变换时，是用进程标志符（进程号）和页号去检索反置页表以获取页框号。地址映射过程如下。
1) 根据进程号和页号找到页框号
2) 物理地址 = 页框号 x 页框大小 + 页内偏移地址。

五、 空闲页框的管理
操作系统需要跟踪和记录空闲页框的信息，两种管理空闲页框的方式。

1. 使用位图管理空闲页框
使用位图管理空闲页框时，使位图中的每一位对应一个页框，具有N个页框的内存需要至少有N个二进制位的位图。当某个二进制位对应的页框被占用时，将该位置1。当该页框空闲时，该位置0.当操作系统为进程分配页框时，检索位图，找对应位为0的页框分配给进程。

2. 使用空闲页框的链表
使用空闲页框链表时，系统维护记录空闲页框信息的链表。空闲页框链表可以按地址递增的顺序排序，每个结点中包含页框的地址信息、指向后面结点的指针和指向前面结点的指针。

## 基于分页的虚拟存储系统
虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。在虚拟存储器系统中，进程无需全部装入，只要装入一部分即可运行。
虚拟存储技术实现的基本思想是，只把进程的一部分装入内存。进程执行过程中，CPU访问内存时如果发现所访问的内存不在内存中，则通过异常处理将所需要的内容从外存调入内存。也即是说将进程的一部分装入内存，其余的部分什么时候需要，什么时候请求系统装入，这就是请求调入。如果在请求系统装入进程在外存中的某一部分时，没有足够的内存，则由操作系统选择一部分内存中的进程内容换出到外存，以腾出内存空间把当前需要装入的内容调入内存，这就是置换。

虚拟存储技术至少能带来以下3点好处
1) 提高内存利用率。因为虚拟存储技术允许只把进程的一部分装入内存，原则上尽量把必须或常用部分装入内存。
2)提高多道程序度。因为只把每个进程的一部分装入内存，因此可以在内存中装入更多的进程。
3)把逻辑地址空间和物理地址空间分开，使程序员不用关心物理内存的容量对编程的限制。

虚拟存储系统具有以下几个主要特征。
1) 离散性。离散性是指进程可以分散地存储在物理内存中。分页、分段和段页式存储都属于离散的内存管理方式。离散性是实现虚拟存储管理的基础。
2) 多次性。多次性是指不必把进程一次性全部装入内存，可以先将执行当前进程所必须的部分代码和数据装入内存，其余部分等进程运行需要时再装入，可以将进程分多次装入内存。
3) 对换性。对换性是指在内存中的进程可以换出，以腾出内存空间换入外存中的进程。为了提高内存的利用率，为程序员提供足够大的虚拟空间，在进程运行期间，系统可以将内存中暂时不用的程序代码或数据换出到外存，以后需要这些进程和代码时再由系统调入内存。
4)虚拟性。 虚拟性是指虚拟存储系统为用户提供了比实际物理内存大的逻辑内存空间，使程序员不必在编程时受物理内存空间大小的限制。虚拟性是实现虚拟存储系统的最重要的目标。

请求分页系统是最基本、最常用的虚拟存储系统的实现方式。其基本原理是，把进程的逻辑地址空间分成大小相同的页，操作系统创建进程时只把进程的一部分页调入内存。进程运行过程中访问内存，若发现所访问的页不在内存中，则产生一个缺页异常信号，系统相应缺页异常，请求调入缺页。若调入缺页时内存已满，则需要先从内存中选择一个或若干个页换出到外存空间，以腾出内存空间容纳请求调入的缺页。

一、请求分页中的硬件支持
为了实现请求分页，需要特殊的页表（相对于基本分页存储和页表而言）、缺页异常机构和支持请求分页的地址变换机构。

1. 页表
页表是支持请求分页系统最重要的数据结构，其作用是记录描述页的各种数据，包括在实现逻辑地址到物理地址映射时需要的页号与页框号的对应关系。除了页号和页框号之外，页表中增加了请求换入和页置换时需要的数据。

2. 缺页异常机构
缺页异常机构的主要作用是在访问内存过程中发现缺页时产生缺页异常信号，使CPU中断当前控制流的执行，转去执行操作系统的缺页异常处理程序，完成请求调页。

3. 地址变换


二、页分配策略

1. 最少页框数
是指能保证进程正常运行时所需要的最少的页框数。如果系统为进程分配的页框数少于这个值，进程将无法正常运行。保证进程正常运行时所需要的最少页框数与进程的大小没有关系，它与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。

2. 页分配和置换策略
在请求分页系统中，从分配给进程的页框数量上来看，可以采用固定分配和可变分配策略。固定分配策略是值在进程从创建到撤销的过程中，为进程分配的页框数保持不变，而可变分配是指为进程分配的页框数是可变的。从选择淘汰页的候选页是请求调入页的进程页还是系统中的所有用户进程页来看，可以采用局部置换和全局置换两种策略。
局部置换是指发生置换时，只从请求调页进程本身的内存页中选择一个被淘汰的页，以腾出内存页框，装入请求调入的页。
全局置换是指置换发生时，从系统中所有进程的内存页中选择被淘汰的页。

1) 固定分配局部置换
在进程创建时为每个进程分配一定数量的页框，在进程运行期间，进程拥有的页框数不再改变。当进程发生缺页时，系统从该进程在内存中的页中选择一页换出，然后再调入请求的页，以保证分配给该进程的内存空间保持不变。

2) 可变分配全局置换
这是在操作系统中被广泛使用的策略。在采用这种策略时，先为系统中的每个进程分配一定数量的页框。同时，操作系统保持一个空闲页框队列。当某进程发生缺页时，由系统从空闲页框队列中取出一个页框分配给该进程，并将欲调入的缺页装入其中。任何产生缺页的进程都可以由系统获得新的页框，以增加本进程在物理内存中的页数。当系统总空闲页框数小于一个规定的阀值时，操作系统会从内存中徐州呢一些页调出，以增加系统的空闲页框数，调出的页可能是系统中任何一个进程的页。

3) 可变分配局部置换
进程创建时，为进程分配一定数目的页框。当进程发生缺页时，只允许从该进程在内存中的页中选出一页换出。只有当进程频繁发生缺页时，操作系统才会为该进程追加页框，以装入更多的进程页，直到该进程的缺页率降低到适当程度。反之，若一个进程在运行过程中的缺页率特别低，则可再不引起进程缺页率明显增加的前提下，适当减少分配给该进程的页框数。


3. 分配算法
操作系统为进程分配的页框数通常都是大于最少页框数的，究竟为每个进程分配多少个页框，可以通过执行页框的分配算法来确定。可采用的页框分配算法如下。
1）平均分配算法
2）按比例分配算法

三、页调入策略
实现请求分页的虚拟存储系统，还需要解决系统应在何时、从何处调入所需页的问题。当系统产生缺页异常时，调入请求页的同时可以只把该页调入内存，也可以在调入该页的同时，把与该页相邻的页也调入内存。外存中的页可以存放于对换去，也可能在文件去。

1. 何时调入页
系统可以设计成只有在进程需要时才将页调入内存。在一种极端的情况下，进程的所有页都不在内存中就开始执行进程。当操作系统将指令指针指向进程的第一条指令时，由于所在的页不在内存中，立即产生缺页异常。当完成缺页异常处理，指令所在的页调入内存后，进程继续执行，执行过程中不断发生缺页异常，将不断将缺页调入内存。当调入足够多的页后，多数需要的页都在内存中来，进程执行将不再出现缺页。这种策略有利于提高内存的利用率，但是对系统的时间性能不利。
大多数系统都采用预先调入页的策略，将预计不久之后会被访问的页预先调入内存，而不是缺哪一页时再调入该页。在实际系统中，通常是在调入缺页时，把与缺页相邻的若干页也调入内存。

2. 从何处调入页
1) 从对换区调入
2) UNIX方式

3. 页调入过程


四、页置换算法
是从内存页中选择换出页的算法

1. 最佳置换算法和先进先出置换算法
1）最佳置换算法，选择该算法以后永远不会被访问的页或者在未来最长时间内不再被访问的页作为换出页。主要作为理论。
2）先进先出置换算法
FIFO是最简单的页置换算法。实现这种算法的一种方式是为每个页记录该页调入内存的时间，当选择换出页时，选择进入内存时间最早的页。最简单的实现方式是创建一个FIFO的队列来管理内存中的所有页，选择队首的页作为换出页。新调入的页被加入到对尾。
FIFO算法实现简单，但是效率较低，会导致较高的缺页率。

2. 最近最久未使用LRU置换算法
FIFO算法实现简单，但是导致最高的缺页率和置换次数，性能较差。而最佳置换算法有最低的页置换次数，性能很好，却难以实现。
LRU算法是广泛使用的性能较好的算法
1) LRU 算法的描述
LRU置换算法是选择最近未使用的页换出（最近最久未使用的页在最近的将来被访问的可能性也较小）
该算法赋予每个页一个访问字段，用来记录一个页自上次被访问以来所经历的时间t。当需要淘汰一个页时，选择现有页中t值最大的页换出。
2) LRU算法的实现
最常用的页置换算法，性能较好，也有较好的实现方法。其实现主要解决两个问题，1是内存中的各个页各有多久时间未被进程访问；2是如何快速地直到哪一页是最近最久未使用的页。

3. 其他置换算法
计算机系统要提供足够的硬件来支持LRU算法是比较困难的，许多系统在实现时都采用LRU的近似算法，如附加引用位算法、简单Clock算法和改进型Clock算法等。
1) 附加引用位算法
2) 简单Clock置换算法
3) 改进型Clock算法
4) 最少使用置换算法
5) 页缓冲算法

五、请求分页系统的性能分析
前面已经阐述来基于请求分页的存储管理的基本原理，在设计和选择虚拟存储管理的策略和算法时，不可避免的要考虑访存的性能。请求调入和置换技术都是以时间换空间的技术。如何在应用这种技术时尽量提高时间性能是在设计系统时需要考虑的问题

1. 缺页率对有效访问时间对影响
进程执行中访存发生缺页时，需要请求从外存调入缺页。如果内存中没有空闲页框，还需要进行页置换，调入缺页后，指令需要重新执行。
因此，一旦发生缺页，进程会存在因为访存而带来的时间延迟。

2. 工作集
1) 基本原理
引入工作集机制是为了能有效降低缺页率，从而提高访存的时间效率。程序在运行时对页的访问是不均匀的，即往往在某些时间内的访问仅局限于较少的若干页，而在另一段时间内，则又可能仅局限于访问另一些较少的页。若能预知在某段时间间隔内要访问哪些页，并能将它们提前调入内存，将会大大降低缺页率，从而减少置换次数，提高CPU的利用率。

2) windows NT的工作集机制
（1） 进程被第一次创建时，为进程指定了一个最小工作集和一个最大工作集。最小工作集和进程正常运行需要调入内存的最小页数。当内存有足够的空间时，可以为进程分配足够的空间以装入它的最大工作集。
（2）当某些进程在内存中的页数小于最大工作集时，若发生缺页，系统从空闲页框队列中取一页框分配给该进程。
（3）当某进程在内存中的页数等于最大工作集时，若发生缺页，系统从该进程的页中按FIFO原则，换出一个该进程的页。
（4）当空闲页框队列中空闲页的数量减到一个最低值时，系统检查所有进程，对工作集大于最小工作集的进程，淘汰该进程的一些页，使该进程的工作集等于最小工作集。

3. 抖动产生对原因和预防方法
（1） 抖动
多道程序度太高，使运行进程的大部分时间都用于进行页的换入、换出，而几乎不能完成任何有效工作的状态成为抖动。引起系统抖动的主要原因是系统中的进程数量太多，每个进程能分配到的页框太少，以至于进程运行过程中频繁请求调页。
（2）抖动和预防
可以采用3中方法预防。 
a. 采取局部置换策略
当进程发现缺页后，仅在进程自己的内存空间范围内置换页，不允许从其他进程获得新的页框。
b. 在CPU调度程序中引入工作集算法。只有当每个进程在内存中都有足够大的驻留集时，才能再从外存中调入新的作业。
c. 挂起若干进程。为了预防抖动，挂起若干进程，腾出进程占用空间。

## 分段存储管理

## Linux的伙伴系统
因为在操作系统中，经常会遇到要为进程分配连续物理内存块的情况，典型的如在Linux中创建新进程时，需要为进程分配连续的8kb空间，即两个连续的页框用于存放task_struc结构和进程的内核推栈。因此，内核应该为分配一组连续的页框而建立一种稳定、高效的分配策略。

Linux的伙伴系统算法把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续的页框。对1024个页框的最大请求对应着4MB大小的连续页框。每个块的第一个页框的物理地址是该块大小的整数倍。例如大小为16个页框的块，其起始地址为16*12的倍数。

